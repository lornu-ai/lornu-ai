name: Synthetic Monitoring

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

permissions:
  contents: read
  issues: write

env:
  PRODUCTION_URL: https://lornu.ai
  STAGING_URL: https://staging.lornu.ai
  DEV_URL: https://d2.lornu.ai

jobs:
  monitor:
    name: Health Check - ${{ github.event.inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        working-directory: apps/web
        run: bun install --frozen-lockfile

      - name: Install Playwright Browsers
        working-directory: apps/web
        run: bunx playwright install chromium --with-deps

      - name: Set environment URL
        id: set-url
        run: |
          ENV="${{ github.event.inputs.environment || 'production' }}"
          case $ENV in
            production) echo "url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT ;;
            staging) echo "url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT ;;
            development) echo "url=${{ env.DEV_URL }}" >> $GITHUB_OUTPUT ;;
          esac
          echo "env=$ENV" >> $GITHUB_OUTPUT

      - name: Run Synthetic Monitoring Tests
        working-directory: apps/web
        env:
          PLAYWRIGHT_BASE_URL: ${{ steps.set-url.outputs.url }}
          CI: true
        run: |
          bun run test:e2e tests/e2e/betterstack-monitoring.spec.ts --project=chromium --reporter=json --output=../../test-results.json || true

      - name: Parse Test Results
        id: parse-results
        run: |
          if [ -f test-results.json ]; then
            # Extract pass/fail counts
            PASSED=$(jq '[.suites[].specs[].tests[] | select(.status == "passed")] | length' test-results.json || echo 0)
            FAILED=$(jq '[.suites[].specs[].tests[] | select(.status == "failed")] | length' test-results.json || echo 0)
            TOTAL=$((PASSED + FAILED))

            echo "passed=$PASSED" >> $GITHUB_OUTPUT
            echo "failed=$FAILED" >> $GITHUB_OUTPUT
            echo "total=$TOTAL" >> $GITHUB_OUTPUT

            if [ $FAILED -gt 0 ]; then
              echo "status=failure" >> $GITHUB_OUTPUT
              echo "success=false" >> $GITHUB_OUTPUT
            else
              echo "status=success" >> $GITHUB_OUTPUT
              echo "success=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=error" >> $GITHUB_OUTPUT
            echo "success=false" >> $GITHUB_OUTPUT
            echo "passed=0" >> $GITHUB_OUTPUT
            echo "failed=0" >> $GITHUB_OUTPUT
            echo "total=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload Playwright Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ steps.set-url.outputs.env }}-${{ github.run_number }}
          path: apps/web/playwright-report/
          retention-days: 30

      - name: Upload Screenshots
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: screenshots-${{ steps.set-url.outputs.env }}-${{ github.run_number }}
          path: apps/web/test-results/
          retention-days: 7

      - name: Create or Update Incident Issue
        if: steps.parse-results.outputs.success == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const env = '${{ steps.set-url.outputs.env }}';
            const url = '${{ steps.set-url.outputs.url }}';
            const passed = '${{ steps.parse-results.outputs.passed }}';
            const failed = '${{ steps.parse-results.outputs.failed }}';
            const total = '${{ steps.parse-results.outputs.total }}';
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            // Read test results for error details
            let errorDetails = 'Test results not available';
            try {
              const results = JSON.parse(fs.readFileSync('test-results.json', 'utf8'));
              const failures = [];
              for (const suite of results.suites || []) {
                for (const spec of suite.specs || []) {
                  for (const test of spec.tests || []) {
                    if (test.status === 'failed') {
                      failures.push(`- **${test.title}**: ${test.error?.message || 'Unknown error'}`);
                    }
                  }
                }
              }
              if (failures.length > 0) {
                errorDetails = failures.join('\n');
              }
            } catch (e) {
              errorDetails = `Failed to parse test results: ${e.message}`;
            }

            const issueTitle = `ðŸš¨ Synthetic Monitoring Alert: ${env} (${url})`;
            const issueBody = `## Monitoring Alert

            **Environment**: \`${env}\`
            **URL**: ${url}
            **Status**: âŒ **FAILING**
            **Time**: ${new Date().toISOString()}

            ### Test Summary
            - âœ… Passed: ${passed}/${total}
            - âŒ Failed: ${failed}/${total}

            ### Failed Tests
            ${errorDetails}

            ### Actions
            - [View Full Report](${runUrl})
            - [Download Screenshots](${runUrl}#artifacts)

            ### Auto-Recovery
            This issue will auto-close if the next scheduled check passes.

            ---
            *Automated by Synthetic Monitoring workflow - runs every 5 minutes*`;

            // Search for existing open incident
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'synthetic-monitoring,incident',
              per_page: 100
            });

            const existingIncident = issues.data.find(issue =>
              issue.title.includes(env) && issue.title.includes('Synthetic Monitoring Alert')
            );

            if (existingIncident) {
              // Update existing incident
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIncident.number,
                body: `### ðŸ”„ Update: Still Failing\n\n${issueBody}`
              });

              core.info(`Updated existing incident: #${existingIncident.number}`);
            } else {
              // Create new incident
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: ['synthetic-monitoring', 'incident', `env:${env}`, 'priority:high']
              });

              core.info(`Created new incident: #${newIssue.data.number}`);
            }

      - name: Close Resolved Incidents
        if: steps.parse-results.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const env = '${{ steps.set-url.outputs.env }}';

            // Find open incidents for this environment
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'synthetic-monitoring,incident',
              per_page: 100
            });

            for (const issue of issues.data) {
              if (issue.title.includes(env) && issue.title.includes('Synthetic Monitoring Alert')) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `### âœ… Resolved\n\nAll health checks are now passing.\n\n**Time**: ${new Date().toISOString()}\n\nClosing incident.`
                });

                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  labels: [...issue.labels.map(l => l.name), 'resolved']
                });

                core.info(`Closed incident: #${issue.number}`);
              }
            }

      - name: Send Slack Notification (Optional)
        if: failure() && vars.SLACK_WEBHOOK_URL
        run: |
          curl -X POST ${{ vars.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "ðŸš¨ Synthetic Monitoring Alert",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Environment*: `${{ steps.set-url.outputs.env }}`\n*URL*: ${{ steps.set-url.outputs.url }}\n*Status*: âŒ FAILING\n*Failed Tests*: ${{ steps.parse-results.outputs.failed }}/${{ steps.parse-results.outputs.total }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }'

      - name: Summary
        if: always()
        run: |
          echo "## Synthetic Monitoring Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ steps.set-url.outputs.env }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL**: ${{ steps.set-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ steps.parse-results.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Passed: ${{ steps.parse-results.outputs.passed }}" >> $GITHUB_STEP_SUMMARY
          echo "- âŒ Failed: ${{ steps.parse-results.outputs.failed }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“Š Total: ${{ steps.parse-results.outputs.total }}" >> $GITHUB_STEP_SUMMARY
